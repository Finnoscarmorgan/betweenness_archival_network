<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Archival Networks: Betweenness centrality</title>
<style>
  html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
  #app { display: grid; grid-template-rows: auto 1fr; height: 100%; }
  header { padding: 10px 14px; border-bottom: 1px solid #ddd; display: grid; gap: 8px; grid-template-columns: 1fr auto auto; align-items: center; }
  header h1 { margin: 0; font-size: 18px; font-weight: 600; }
  .controls { display: inline-flex; gap: 8px; align-items: center; }
  .controls input[type="text"] { padding: 6px 8px; border: 1px solid #ccc; border-radius: 4px; width: 280px; }
  .controls label { font-size: 14px; }
  .legend { display: inline-flex; align-items: center; gap: 14px; font-size: 13px; }
  .legend .item { display: inline-flex; align-items: center; gap: 6px; }
  .legend .swatch { width: 12px; height: 12px; border-radius: 50%; border: 1px solid #999; }
  #chart { position: relative; }
  svg { width: 100%; height: 100%; display: block; background: #fafafa; }
  .node { cursor: pointer; }
  .node circle { stroke: #fff; stroke-width: 1px; }
  .node.highlight circle { stroke-width: 2px; }
  .link { stroke: #bbb; stroke-opacity: 0.6; }
  .link.highlight { stroke-opacity: 0.95; }
  .tooltip {
    position: absolute; pointer-events: none; background: rgba(255,255,255,0.98);
    border: 1px solid #ccc; border-radius: 4px; padding: 8px 10px; font-size: 12px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.08);
  }
  .panel { position: absolute; right: 12px; top: 12px; background: rgba(255,255,255,0.98);
    border: 1px solid #ddd; padding: 10px; border-radius: 6px; font-size: 13px; max-width: 320px;
  }
  .panel h3 { margin: 0 0 6px 0; font-size: 14px; }
  .muted { color: #666; }
  /* Focus mode button */
  #exit-focus {
    position: absolute; left: 12px; top: 12px; padding: 6px 10px; font-size: 13px;
    border: 1px solid #ccc; border-radius: 4px; background: white; cursor: pointer; display: none;
  }
</style>
</head>
<body>
<div id="app">
  <header>
    <h1>Archival Networks: archive holders and mentions sized by betweenness centrality</h1>

    <div class="controls">
      <input id="search" type="text" placeholder="Search nameâ€¦" />
      <label><input id="toggle-mentioned" type="checkbox" checked /> Show mentioned-only nodes</label>
      <label><input id="toggle-holders" type="checkbox" checked /> Show archive holders</label>
      <label><input id="toggle-dir" type="checkbox" /> Show direction</label>
    </div>

    <div class="legend">
      <div class="item"><span class="swatch" style="background:#1f77b4"></span> Archive holder</div>
      <div class="item"><span class="swatch" style="background:#999"></span> Mentioned only</div>
      <div class="item"><span class="swatch" style="background:linear-gradient(90deg,#eee,#000)"></span> Size = betweenness</div>
    </div>
  </header>

  <div id="chart">
    <button id="exit-focus" title="Exit focus view">Exit focus</button>
    <svg></svg>
    <div class="panel" id="info">
      <h3>About this view</h3>
      <p>This visualisation shows a link from an archive holder to every person named in that catalogue record. Node size is proportional to betweenness centrality, which highlights bridging figures that connect otherwise separate parts of the network. Use search to locate a person. Click a node to enter focus mode and see only that node and its immediate connections. Click the background or press Esc to exit focus.</p>
      <!--<p class="muted">Files read: <code>Network_A_nodes.csv</code>, <code>Network_A_links.csv</code></p>-->
    </div>
    <div class="tooltip" style="display:none;" id="tooltip"></div>
  </div>
</div>

<!-- D3 v7 from CDN -->
<script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
<script>
(async function() {
  const files = {
    nodes: 'Network_A_nodes_with_betweenness.csv',
    links: 'Network_A_links.csv'
  };

  const [nodesRaw, linksRaw] = await Promise.all([
    d3.csv(files.nodes, d3.autoType),
    d3.csv(files.links, d3.autoType)
  ]);

  const nodeById = new Map(nodesRaw.map(d => [String(d.id), d]));
  const links = linksRaw.filter(d => nodeById.has(String(d.source)) && nodeById.has(String(d.target)));

  const nodes = nodesRaw.map(d => ({
    id: String(d.id),
    name: d.name,
    type: d.type,
    betweenness: +d.betweenness || 0,
    in_strength: +d.in_strength || 0,
    out_strength: +d.out_strength || 0
  }));

  const betExtent = d3.extent(nodes, d => d.betweenness);
  const size = d3.scaleSqrt().domain([Math.max(0, betExtent[0] || 0), Math.max(1e-6, betExtent[1] || 1e-3)]).range([3, 18]);
  const colour = d => d.type === 'archive_holder' ? '#1f77b4' : '#999';

  const svg = d3.select('svg');
  svg.attr('width', 900).attr('height', 600);
  const width = svg.node().clientWidth;
  const height = svg.node().clientHeight;

  const g = svg.append('g');
  const linkLayer = g.append('g').attr('stroke-linecap', 'round');
  const nodeLayer = g.append('g');

// Define arrowhead marker once
const defs = svg.append('defs');
defs.append('marker')
  .attr('id', 'arrow')
  .attr('viewBox', '0 -3 6 6')
  .attr('refX', 20)          // tune for your node sizes
  .attr('refY', 0)
  .attr('markerWidth', 6)
  .attr('markerHeight', 6)
  .attr('orient', 'auto')
  .append('path')
    .attr('d', 'M0,-3L6,0L0,3Z')
    .attr('fill', '#bbb');            // fixed, reliable colour

  const simulation = d3.forceSimulation(nodes)
    .force('link', d3.forceLink(links).id(d => d.id).distance(40).strength(0.05))
    .force('charge', d3.forceManyBody().strength(-30))
    .force('center', d3.forceCenter(width / 2, height / 2))
    .force('collide', d3.forceCollide().radius(d => size(d.betweenness) + 2));

  // Create links
const link = linkLayer.selectAll('line')
  .data(links)
  .join('line')
  .attr('class', 'link')
  .attr('stroke-width', 1)
  .attr('stroke', '#bbb');   // line colour

  
  // Direction toggle: show or hide arrowheads
const chkDir = document.getElementById('toggle-dir');
chkDir.addEventListener('change', () => {
  link.attr('marker-end', chkDir.checked ? 'url(#arrow)' : null);
});


  const node = nodeLayer.selectAll('g.node')
    .data(nodes)
    .join('g')
    .attr('class', 'node')
    .call(drag(simulation));

  node.append('circle')
    .attr('r', d => size(d.betweenness))
    .attr('fill', d => colour(d))
    .attr('opacity', 0.5);
    
  node.append('title').text(d => `${d.name}
Type: ${d.type}
Betweenness: ${d.betweenness.toFixed(6)}
Mentioned by: ${d.in_strength}
Mentions made: ${d.out_strength}`);

  const tooltip = d3.select('#tooltip');
  node.on('mousemove', function(event, d) {
      tooltip.style('display', 'block')
        .style('left', (event.clientX + 12) + 'px')
        .style('top', (event.clientY + 12) + 'px')
        .html(`<strong>${d.name}</strong><br/>
               Type: ${d.type.replace('_', ' ')}<br/>
               Betweenness: ${d.betweenness.toFixed(6)}<br/>
               Mentioned by: ${d.in_strength}<br/>
               Mentions made: ${d.out_strength}`);
    })
    .on('mouseleave', () => tooltip.style('display', 'none'));

  // Focus mode state
  let focusedId = null;
  const exitBtn = document.getElementById('exit-focus');

  // Enter focus on node click
  node.on('click', function(event, d) {
    event.stopPropagation();
    if (focusedId === d.id) { clearFocus(); return; }
    focusNode(d.id);
    centerOnNode(d);
  });

  // Exit focus on background click or Esc
  svg.on('click', clearFocus);
  window.addEventListener('keydown', e => { if (e.key === 'Escape') clearFocus(); });
  exitBtn.addEventListener('click', clearFocus);

  // Search still works. If you search, it will also enter focus mode on the first match.
  const searchInput = document.getElementById('search');
  searchInput.addEventListener('input', () => {
    const q = searchInput.value.trim().toLowerCase();
    if (!q) { clearFocus(); return; }
    const match = nodes.find(n => n.name && n.name.toLowerCase().includes(q));
    if (match) { focusNode(match.id); }
  });

  // Respect the two visibility toggles even outside focus mode
  const chkMentioned = document.getElementById('toggle-mentioned');
  const chkHolders = document.getElementById('toggle-holders');
  chkMentioned.addEventListener('change', () => { if (!focusedId) applyFilters(); });
  chkHolders.addEventListener('change', () => { if (!focusedId) applyFilters(); });

  function applyFilters() {
    node.style('display', d => {
      if (d.type === 'mentioned_only' && !chkMentioned.checked) return 'none';
      if (d.type === 'archive_holder' && !chkHolders.checked) return 'none';
      return null;
    });
    const hidden = new Set();
    node.each(function(d){ if (this.style.display === 'none') hidden.add(d.id); });
    link.style('display', d => hidden.has(String(d.source.id || d.source)) || hidden.has(String(d.target.id || d.target)) ? 'none' : null);
  }

  // Focus mode: hide everything except the selected node and its immediate neighbours
  function focusNode(id) {
    focusedId = id;
    exitBtn.style.display = 'inline-block';

    const neigh = neighbourhood(id); // returns Set of ids to keep
    node.style('display', d => neigh.has(d.id) ? null : 'none');
    link.style('display', d => {
      const s = d.source.id || d.source;
      const t = d.target.id || d.target;
      return (s === id || t === id) ? null : 'none';
    });
  }

  function clearFocus() {
    if (!focusedId) return;
    focusedId = null;
    exitBtn.style.display = 'none';
    node.style('display', null);
    link.style('display', null);
    applyFilters(); // reapply user toggles
  }

  function neighbourhood(id) {
    const keep = new Set([id]);
    links.forEach(l => {
      const s = l.source.id || l.source, t = l.target.id || l.target;
      if (s === id) keep.add(t);
      if (t === id) keep.add(s);
    });
    return keep;
  }

  // Zoom and pan
  const zoom = d3.zoom().scaleExtent([0.2, 6]).on('zoom', (event) => g.attr('transform', event.transform));
  svg.call(zoom);

  simulation.on('tick', () => {
    link.attr('x1', d => d.source.x).attr('y1', d => d.source.y)
        .attr('x2', d => d.target.x).attr('y2', d => d.target.y);
    node.attr('transform', d => `translate(${d.x},${d.y})`);
  });

  function centerOnNode(d) {
    const t = d3.zoomTransform(svg.node());
    const k = t.k || 1;
    svg.transition().duration(600).call(zoom.translateTo, d.x, d.y);
  }

  function drag(sim) {
    function dragstarted(event, d) { if (!event.active) sim.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; }
    function dragged(event, d) { d.fx = event.x; d.fy = event.y; }
    function dragended(event, d) { if (!event.active) sim.alphaTarget(0); d.fx = null; d.fy = null; }
    return d3.drag().on('start', dragstarted).on('drag', dragged).on('end', dragended);
  }

  // Initial filters
  applyFilters();
})();
</script>
</body>
</html>
